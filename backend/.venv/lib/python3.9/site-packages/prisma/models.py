# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template models.py.jinja --
import os
import logging
import inspect
import warnings
from collections import OrderedDict

from pydantic import BaseModel, Field

from . import types, enums, errors, fields, bases
from ._types import FuncType
from ._compat import model_rebuild, field_validator
from ._builder import serialize_base64
from .generator import partial_models_ctx, PartialModelField


log: logging.Logger = logging.getLogger(__name__)
_created_partial_types: Set[str] = set()

class User(bases.BaseUser):
    """Represents a User record"""

    id: _str
    email: _str
    passwordHash: _str
    fullName: _str
    role: 'enums.UserRole'
    phone: Optional[_str] = None
    isActive: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    permissions: Optional[List['models.UserPermission']] = None
    organizations: Optional[List['models.OrganizationMember']] = None
    Repair: Optional[List['models.Repair']] = None
    StatusHistory: Optional[List['models.StatusHistory']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UserKeys']] = None,
        exclude: Optional[Iterable['types.UserKeys']] = None,
        required: Optional[Iterable['types.UserKeys']] = None,
        optional: Optional[Iterable['types.UserKeys']] = None,
        relations: Optional[Mapping['types.UserRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UserKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _User_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _User_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _User_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _User_relational_fields:
                        raise errors.UnknownRelationalFieldError('User', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid User / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'User',
            }
        )
        _created_partial_types.add(name)


class Permission(bases.BasePermission):
    """Represents a Permission record"""

    id: _str
    code: _str
    name: _str
    description: Optional[_str] = None
    isActive: _bool
    userPermissions: Optional[List['models.UserPermission']] = None
    rolePermissions: Optional[List['models.RolePermission']] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.PermissionKeys']] = None,
        exclude: Optional[Iterable['types.PermissionKeys']] = None,
        required: Optional[Iterable['types.PermissionKeys']] = None,
        optional: Optional[Iterable['types.PermissionKeys']] = None,
        relations: Optional[Mapping['types.PermissionRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.PermissionKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Permission_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Permission_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Permission_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Permission_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Permission_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Permission_relational_fields:
                        raise errors.UnknownRelationalFieldError('Permission', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Permission / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Permission',
            }
        )
        _created_partial_types.add(name)


class UserPermission(bases.BaseUserPermission):
    """Represents a UserPermission record"""

    id: _str
    userId: _str
    permissionId: _str
    granted: _bool
    user: Optional['models.User'] = None
    permission: Optional['models.Permission'] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UserPermissionKeys']] = None,
        exclude: Optional[Iterable['types.UserPermissionKeys']] = None,
        required: Optional[Iterable['types.UserPermissionKeys']] = None,
        optional: Optional[Iterable['types.UserPermissionKeys']] = None,
        relations: Optional[Mapping['types.UserPermissionRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UserPermissionKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _UserPermission_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _UserPermission_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _UserPermission_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _UserPermission_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _UserPermission_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _UserPermission_relational_fields:
                        raise errors.UnknownRelationalFieldError('UserPermission', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid UserPermission / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'UserPermission',
            }
        )
        _created_partial_types.add(name)


class RolePermission(bases.BaseRolePermission):
    """Represents a RolePermission record"""

    id: _str
    role: 'enums.UserRole'
    permissionId: _str
    permission: Optional['models.Permission'] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.RolePermissionKeys']] = None,
        exclude: Optional[Iterable['types.RolePermissionKeys']] = None,
        required: Optional[Iterable['types.RolePermissionKeys']] = None,
        optional: Optional[Iterable['types.RolePermissionKeys']] = None,
        relations: Optional[Mapping['types.RolePermissionRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.RolePermissionKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _RolePermission_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _RolePermission_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _RolePermission_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _RolePermission_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _RolePermission_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _RolePermission_relational_fields:
                        raise errors.UnknownRelationalFieldError('RolePermission', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid RolePermission / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'RolePermission',
            }
        )
        _created_partial_types.add(name)


class Organization(bases.BaseOrganization):
    """Represents a Organization record"""

    id: _str
    name: _str
    description: Optional[_str] = None
    businessNumber: Optional[_str] = None
    address: Optional[_str] = None
    phone: Optional[_str] = None
    email: Optional[_str] = None
    isActive: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    members: Optional[List['models.OrganizationMember']] = None
    drivers: Optional[List['models.Driver']] = None
    vehicles: Optional[List['models.Vehicle']] = None
    maintenances: Optional[List['models.Maintenance']] = None
    erpSyncConfigs: Optional[List['models.ERPSyncConfig']] = None
    erpSyncLogs: Optional[List['models.ERPSyncLog']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.OrganizationKeys']] = None,
        exclude: Optional[Iterable['types.OrganizationKeys']] = None,
        required: Optional[Iterable['types.OrganizationKeys']] = None,
        optional: Optional[Iterable['types.OrganizationKeys']] = None,
        relations: Optional[Mapping['types.OrganizationRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.OrganizationKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Organization_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Organization_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Organization_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Organization_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Organization_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Organization_relational_fields:
                        raise errors.UnknownRelationalFieldError('Organization', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Organization / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Organization',
            }
        )
        _created_partial_types.add(name)


class OrganizationMember(bases.BaseOrganizationMember):
    """Represents a OrganizationMember record"""

    id: _str
    userId: _str
    organizationId: _str
    role: 'enums.UserRole'
    isActive: _bool
    joinedAt: datetime.datetime
    user: Optional['models.User'] = None
    organization: Optional['models.Organization'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.OrganizationMemberKeys']] = None,
        exclude: Optional[Iterable['types.OrganizationMemberKeys']] = None,
        required: Optional[Iterable['types.OrganizationMemberKeys']] = None,
        optional: Optional[Iterable['types.OrganizationMemberKeys']] = None,
        relations: Optional[Mapping['types.OrganizationMemberRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.OrganizationMemberKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _OrganizationMember_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _OrganizationMember_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _OrganizationMember_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _OrganizationMember_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _OrganizationMember_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _OrganizationMember_relational_fields:
                        raise errors.UnknownRelationalFieldError('OrganizationMember', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid OrganizationMember / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'OrganizationMember',
            }
        )
        _created_partial_types.add(name)


class Driver(bases.BaseDriver):
    """Represents a Driver record"""

    id: _str
    name: _str
    email: _str
    phone: _str
    licenseNumber: _str
    licenseType: Optional[_str] = None
    licenseExpiry: datetime.datetime
    isActive: _bool
    restrictions: List[_str]
    notes: Optional[_str] = None
    assignedVehicles: List[_str]
    emergencyContact: Optional['fields.Json'] = None
    address: Optional[_str] = None
    birthDate: Optional[datetime.datetime] = None
    hireDate: Optional[datetime.datetime] = None
    department: Optional[_str] = None
    position: Optional[_str] = None
    profileImageUrl: Optional[_str] = None
    organizationId: _str
    organization: Optional['models.Organization'] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    performanceData: Optional[List['models.DriverPerformance']] = None
    drivingRecords: Optional[List['models.DrivingRecord']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @field_validator('restrictions', 'assignedVehicles', pre=True, allow_reuse=True)
    @classmethod
    def _transform_required_list_fields(cls, value: object) -> object:
        # When using raw queries, some databases will return `None` for an array field that has not been set yet.
        #
        # In our case we want to use an empty list instead as that is the internal Prisma behaviour and we want
        # to use the same consistent structure between the core ORM and raw queries. For example, if we updated
        # our type definitions to include `None` for `List` fields then it would be misleading as it will only
        # ever be `None` in raw queries.
        if value is None:
            return []

        return value

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.DriverKeys']] = None,
        exclude: Optional[Iterable['types.DriverKeys']] = None,
        required: Optional[Iterable['types.DriverKeys']] = None,
        optional: Optional[Iterable['types.DriverKeys']] = None,
        relations: Optional[Mapping['types.DriverRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.DriverKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Driver_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Driver_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Driver_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Driver_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Driver_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Driver_relational_fields:
                        raise errors.UnknownRelationalFieldError('Driver', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Driver / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Driver',
            }
        )
        _created_partial_types.add(name)


class Vehicle(bases.BaseVehicle):
    """Represents a Vehicle record"""

    id: _str
    make: _str
    model: _str
    year: _int
    vehicleType: _str
    licensePlate: _str
    vin: _str
    color: Optional[_str] = None
    mileage: _int
    fuelType: Optional[_str] = None
    transmission: Optional[_str] = None
    engine: Optional[_str] = None
    features: List[_str]
    notes: Optional[_str] = None
    status: _str
    organizationId: _str
    organization: Optional['models.Organization'] = None
    maintenances: Optional[List['models.Maintenance']] = None
    drivingRecords: Optional[List['models.DrivingRecord']] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @field_validator('features', pre=True, allow_reuse=True)
    @classmethod
    def _transform_required_list_fields(cls, value: object) -> object:
        # When using raw queries, some databases will return `None` for an array field that has not been set yet.
        #
        # In our case we want to use an empty list instead as that is the internal Prisma behaviour and we want
        # to use the same consistent structure between the core ORM and raw queries. For example, if we updated
        # our type definitions to include `None` for `List` fields then it would be misleading as it will only
        # ever be `None` in raw queries.
        if value is None:
            return []

        return value

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.VehicleKeys']] = None,
        exclude: Optional[Iterable['types.VehicleKeys']] = None,
        required: Optional[Iterable['types.VehicleKeys']] = None,
        optional: Optional[Iterable['types.VehicleKeys']] = None,
        relations: Optional[Mapping['types.VehicleRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.VehicleKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Vehicle_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Vehicle_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Vehicle_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Vehicle_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Vehicle_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Vehicle_relational_fields:
                        raise errors.UnknownRelationalFieldError('Vehicle', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Vehicle / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Vehicle',
            }
        )
        _created_partial_types.add(name)


class Maintenance(bases.BaseMaintenance):
    """Represents a Maintenance record"""

    id: _str
    title: _str
    description: Optional[_str] = None
    maintenanceType: 'enums.MaintenanceType'
    status: 'enums.MaintenanceStatus'
    startDate: datetime.datetime
    endDate: Optional[datetime.datetime] = None
    mileageAtService: Optional[_int] = None
    cost: Optional[_float] = None
    provider: Optional[_str] = None
    providerContact: Optional[_str] = None
    documents: List[_str]
    notes: Optional[_str] = None
    vehicleId: _str
    vehicle: Optional['models.Vehicle'] = None
    organizationId: _str
    organization: Optional['models.Organization'] = None
    parts: Optional[List['models.MaintenancePart']] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @field_validator('documents', pre=True, allow_reuse=True)
    @classmethod
    def _transform_required_list_fields(cls, value: object) -> object:
        # When using raw queries, some databases will return `None` for an array field that has not been set yet.
        #
        # In our case we want to use an empty list instead as that is the internal Prisma behaviour and we want
        # to use the same consistent structure between the core ORM and raw queries. For example, if we updated
        # our type definitions to include `None` for `List` fields then it would be misleading as it will only
        # ever be `None` in raw queries.
        if value is None:
            return []

        return value

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.MaintenanceKeys']] = None,
        exclude: Optional[Iterable['types.MaintenanceKeys']] = None,
        required: Optional[Iterable['types.MaintenanceKeys']] = None,
        optional: Optional[Iterable['types.MaintenanceKeys']] = None,
        relations: Optional[Mapping['types.MaintenanceRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.MaintenanceKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Maintenance_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Maintenance_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Maintenance_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Maintenance_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Maintenance_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Maintenance_relational_fields:
                        raise errors.UnknownRelationalFieldError('Maintenance', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Maintenance / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Maintenance',
            }
        )
        _created_partial_types.add(name)


class MaintenancePart(bases.BaseMaintenancePart):
    """Represents a MaintenancePart record"""

    id: _str
    name: _str
    partNumber: Optional[_str] = None
    quantity: _int
    unitPrice: Optional[_float] = None
    totalPrice: Optional[_float] = None
    maintenanceId: _str
    maintenance: Optional['models.Maintenance'] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.MaintenancePartKeys']] = None,
        exclude: Optional[Iterable['types.MaintenancePartKeys']] = None,
        required: Optional[Iterable['types.MaintenancePartKeys']] = None,
        optional: Optional[Iterable['types.MaintenancePartKeys']] = None,
        relations: Optional[Mapping['types.MaintenancePartRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.MaintenancePartKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _MaintenancePart_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _MaintenancePart_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _MaintenancePart_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _MaintenancePart_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _MaintenancePart_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _MaintenancePart_relational_fields:
                        raise errors.UnknownRelationalFieldError('MaintenancePart', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid MaintenancePart / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'MaintenancePart',
            }
        )
        _created_partial_types.add(name)


class DriverPerformance(bases.BaseDriverPerformance):
    """Represents a DriverPerformance record"""

    id: _str
    driverId: _str
    driver: Optional['models.Driver'] = None
    periodStart: datetime.datetime
    periodEnd: datetime.datetime
    totalDistance: _float
    avgSpeed: Optional[_float] = None
    maxSpeed: Optional[_float] = None
    hardBrakeCount: Optional[_int] = None
    hardAccelerationCount: Optional[_int] = None
    idlingDuration: Optional[_int] = None
    fuelConsumption: Optional[_float] = None
    avgFuelEfficiency: Optional[_float] = None
    co2Emission: Optional[_float] = None
    safetyScore: Optional[_int] = None
    ecoScore: Optional[_int] = None
    overallScore: Optional[_int] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.DriverPerformanceKeys']] = None,
        exclude: Optional[Iterable['types.DriverPerformanceKeys']] = None,
        required: Optional[Iterable['types.DriverPerformanceKeys']] = None,
        optional: Optional[Iterable['types.DriverPerformanceKeys']] = None,
        relations: Optional[Mapping['types.DriverPerformanceRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.DriverPerformanceKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _DriverPerformance_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _DriverPerformance_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _DriverPerformance_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _DriverPerformance_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _DriverPerformance_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _DriverPerformance_relational_fields:
                        raise errors.UnknownRelationalFieldError('DriverPerformance', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid DriverPerformance / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'DriverPerformance',
            }
        )
        _created_partial_types.add(name)


class DrivingRecord(bases.BaseDrivingRecord):
    """Represents a DrivingRecord record"""

    id: _str
    driverId: _str
    driver: Optional['models.Driver'] = None
    vehicleId: _str
    vehicle: Optional['models.Vehicle'] = None
    startTime: datetime.datetime
    endTime: datetime.datetime
    startLocation: Optional[_str] = None
    endLocation: Optional[_str] = None
    distance: _float
    avgSpeed: Optional[_float] = None
    maxSpeed: Optional[_float] = None
    fuelConsumption: Optional[_float] = None
    hardBrakeCount: Optional[_int] = None
    hardAccelCount: Optional[_int] = None
    idlingDuration: Optional[_int] = None
    routeData: Optional['fields.Json'] = None
    notes: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.DrivingRecordKeys']] = None,
        exclude: Optional[Iterable['types.DrivingRecordKeys']] = None,
        required: Optional[Iterable['types.DrivingRecordKeys']] = None,
        optional: Optional[Iterable['types.DrivingRecordKeys']] = None,
        relations: Optional[Mapping['types.DrivingRecordRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.DrivingRecordKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _DrivingRecord_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _DrivingRecord_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _DrivingRecord_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _DrivingRecord_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _DrivingRecord_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _DrivingRecord_relational_fields:
                        raise errors.UnknownRelationalFieldError('DrivingRecord', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid DrivingRecord / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'DrivingRecord',
            }
        )
        _created_partial_types.add(name)


class ERPSyncConfig(bases.BaseERPSyncConfig):
    """Represents a ERPSyncConfig record"""

    id: _str
    name: _str
    erpSystem: 'enums.ERPSystemType'
    connectionUrl: _str
    username: _str
    password: _str
    syncDirection: 'enums.SyncDirectionType'
    syncInterval: Optional[_int] = None
    syncEnabled: _bool
    lastSyncTime: Optional[datetime.datetime] = None
    mappingConfig: 'fields.Json'
    filters: 'fields.Json'
    organizationId: _str
    organization: Optional['models.Organization'] = None
    syncLogs: Optional[List['models.ERPSyncLog']] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ERPSyncConfigKeys']] = None,
        exclude: Optional[Iterable['types.ERPSyncConfigKeys']] = None,
        required: Optional[Iterable['types.ERPSyncConfigKeys']] = None,
        optional: Optional[Iterable['types.ERPSyncConfigKeys']] = None,
        relations: Optional[Mapping['types.ERPSyncConfigRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ERPSyncConfigKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _ERPSyncConfig_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _ERPSyncConfig_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _ERPSyncConfig_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _ERPSyncConfig_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _ERPSyncConfig_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _ERPSyncConfig_relational_fields:
                        raise errors.UnknownRelationalFieldError('ERPSyncConfig', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid ERPSyncConfig / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'ERPSyncConfig',
            }
        )
        _created_partial_types.add(name)


class ERPSyncLog(bases.BaseERPSyncLog):
    """Represents a ERPSyncLog record"""

    id: _str
    configId: _str
    config: Optional['models.ERPSyncConfig'] = None
    status: 'enums.SyncStatusType'
    startTime: datetime.datetime
    endTime: Optional[datetime.datetime] = None
    direction: 'enums.SyncDirectionType'
    totalItems: Optional[_int] = None
    processedItems: Optional[_int] = None
    successItems: Optional[_int] = None
    failedItems: Optional[_int] = None
    errorDetails: Optional[_str] = None
    organizationId: _str
    organization: Optional['models.Organization'] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ERPSyncLogKeys']] = None,
        exclude: Optional[Iterable['types.ERPSyncLogKeys']] = None,
        required: Optional[Iterable['types.ERPSyncLogKeys']] = None,
        optional: Optional[Iterable['types.ERPSyncLogKeys']] = None,
        relations: Optional[Mapping['types.ERPSyncLogRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ERPSyncLogKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _ERPSyncLog_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _ERPSyncLog_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _ERPSyncLog_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _ERPSyncLog_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _ERPSyncLog_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _ERPSyncLog_relational_fields:
                        raise errors.UnknownRelationalFieldError('ERPSyncLog', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid ERPSyncLog / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'ERPSyncLog',
            }
        )
        _created_partial_types.add(name)


class Repair(bases.BaseRepair):
    """Represents a Repair record"""

    id: _str
    vehicle_id: _str
    repair_type: 'enums.RepairType'
    description: _str
    estimated_hours: _float
    technician_id: Optional[_str] = None
    technician: Optional['models.User'] = None
    reservation_id: Optional[_str] = None
    start_time: Optional[datetime.datetime] = None
    completion_time: Optional[datetime.datetime] = None
    status: 'enums.RepairStatus'
    parts_required: _bool
    notes: Optional[_str] = None
    created_at: datetime.datetime
    updated_at: datetime.datetime
    statusHistories: Optional[List['models.StatusHistory']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.RepairKeys']] = None,
        exclude: Optional[Iterable['types.RepairKeys']] = None,
        required: Optional[Iterable['types.RepairKeys']] = None,
        optional: Optional[Iterable['types.RepairKeys']] = None,
        relations: Optional[Mapping['types.RepairRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.RepairKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Repair_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Repair_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Repair_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Repair_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Repair_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Repair_relational_fields:
                        raise errors.UnknownRelationalFieldError('Repair', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Repair / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Repair',
            }
        )
        _created_partial_types.add(name)


class StatusHistory(bases.BaseStatusHistory):
    """Represents a StatusHistory record"""

    id: _str
    repair_id: _str
    repair: Optional['models.Repair'] = None
    status: 'enums.RepairStatus'
    timestamp: datetime.datetime
    note: Optional[_str] = None
    technician_id: Optional[_str] = None
    technician: Optional['models.User'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.StatusHistoryKeys']] = None,
        exclude: Optional[Iterable['types.StatusHistoryKeys']] = None,
        required: Optional[Iterable['types.StatusHistoryKeys']] = None,
        optional: Optional[Iterable['types.StatusHistoryKeys']] = None,
        relations: Optional[Mapping['types.StatusHistoryRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.StatusHistoryKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _StatusHistory_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _StatusHistory_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _StatusHistory_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _StatusHistory_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _StatusHistory_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _StatusHistory_relational_fields:
                        raise errors.UnknownRelationalFieldError('StatusHistory', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid StatusHistory / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'StatusHistory',
            }
        )
        _created_partial_types.add(name)



_User_relational_fields: Set[str] = {
        'permissions',
        'organizations',
        'Repair',
        'StatusHistory',
    }
_User_fields: Dict['types.UserKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('passwordHash', {
            'name': 'passwordHash',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('fullName', {
            'name': 'fullName',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('role', {
            'name': 'role',
            'is_list': False,
            'optional': False,
            'type': 'enums.UserRole',
            'is_relational': False,
            'documentation': None,
        }),
        ('phone', {
            'name': 'phone',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('isActive', {
            'name': 'isActive',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('permissions', {
            'name': 'permissions',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.UserPermission\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('organizations', {
            'name': 'organizations',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.OrganizationMember\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('Repair', {
            'name': 'Repair',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Repair\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('StatusHistory', {
            'name': 'StatusHistory',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.StatusHistory\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Permission_relational_fields: Set[str] = {
        'userPermissions',
        'rolePermissions',
    }
_Permission_fields: Dict['types.PermissionKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('code', {
            'name': 'code',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('isActive', {
            'name': 'isActive',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('userPermissions', {
            'name': 'userPermissions',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.UserPermission\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('rolePermissions', {
            'name': 'rolePermissions',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.RolePermission\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_UserPermission_relational_fields: Set[str] = {
        'user',
        'permission',
    }
_UserPermission_fields: Dict['types.UserPermissionKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('permissionId', {
            'name': 'permissionId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('granted', {
            'name': 'granted',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('permission', {
            'name': 'permission',
            'is_list': False,
            'optional': True,
            'type': 'models.Permission',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_RolePermission_relational_fields: Set[str] = {
        'permission',
    }
_RolePermission_fields: Dict['types.RolePermissionKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('role', {
            'name': 'role',
            'is_list': False,
            'optional': False,
            'type': 'enums.UserRole',
            'is_relational': False,
            'documentation': None,
        }),
        ('permissionId', {
            'name': 'permissionId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('permission', {
            'name': 'permission',
            'is_list': False,
            'optional': True,
            'type': 'models.Permission',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Organization_relational_fields: Set[str] = {
        'members',
        'drivers',
        'vehicles',
        'maintenances',
        'erpSyncConfigs',
        'erpSyncLogs',
    }
_Organization_fields: Dict['types.OrganizationKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('businessNumber', {
            'name': 'businessNumber',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('address', {
            'name': 'address',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('phone', {
            'name': 'phone',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('isActive', {
            'name': 'isActive',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('members', {
            'name': 'members',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.OrganizationMember\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('drivers', {
            'name': 'drivers',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Driver\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('vehicles', {
            'name': 'vehicles',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Vehicle\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('maintenances', {
            'name': 'maintenances',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Maintenance\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('erpSyncConfigs', {
            'name': 'erpSyncConfigs',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ERPSyncConfig\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('erpSyncLogs', {
            'name': 'erpSyncLogs',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ERPSyncLog\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_OrganizationMember_relational_fields: Set[str] = {
        'user',
        'organization',
    }
_OrganizationMember_fields: Dict['types.OrganizationMemberKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('organizationId', {
            'name': 'organizationId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('role', {
            'name': 'role',
            'is_list': False,
            'optional': False,
            'type': 'enums.UserRole',
            'is_relational': False,
            'documentation': None,
        }),
        ('isActive', {
            'name': 'isActive',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('joinedAt', {
            'name': 'joinedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('organization', {
            'name': 'organization',
            'is_list': False,
            'optional': True,
            'type': 'models.Organization',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Driver_relational_fields: Set[str] = {
        'organization',
        'performanceData',
        'drivingRecords',
    }
_Driver_fields: Dict['types.DriverKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('phone', {
            'name': 'phone',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('licenseNumber', {
            'name': 'licenseNumber',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('licenseType', {
            'name': 'licenseType',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('licenseExpiry', {
            'name': 'licenseExpiry',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('isActive', {
            'name': 'isActive',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('restrictions', {
            'name': 'restrictions',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('notes', {
            'name': 'notes',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('assignedVehicles', {
            'name': 'assignedVehicles',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('emergencyContact', {
            'name': 'emergencyContact',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('address', {
            'name': 'address',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('birthDate', {
            'name': 'birthDate',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('hireDate', {
            'name': 'hireDate',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('department', {
            'name': 'department',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('position', {
            'name': 'position',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('profileImageUrl', {
            'name': 'profileImageUrl',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('organizationId', {
            'name': 'organizationId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('organization', {
            'name': 'organization',
            'is_list': False,
            'optional': True,
            'type': 'models.Organization',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('performanceData', {
            'name': 'performanceData',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.DriverPerformance\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('drivingRecords', {
            'name': 'drivingRecords',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.DrivingRecord\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Vehicle_relational_fields: Set[str] = {
        'organization',
        'maintenances',
        'drivingRecords',
    }
_Vehicle_fields: Dict['types.VehicleKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('make', {
            'name': 'make',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('model', {
            'name': 'model',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('year', {
            'name': 'year',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('vehicleType', {
            'name': 'vehicleType',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('licensePlate', {
            'name': 'licensePlate',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('vin', {
            'name': 'vin',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('color', {
            'name': 'color',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('mileage', {
            'name': 'mileage',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('fuelType', {
            'name': 'fuelType',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('transmission', {
            'name': 'transmission',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('engine', {
            'name': 'engine',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('features', {
            'name': 'features',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('notes', {
            'name': 'notes',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('organizationId', {
            'name': 'organizationId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('organization', {
            'name': 'organization',
            'is_list': False,
            'optional': True,
            'type': 'models.Organization',
            'is_relational': True,
            'documentation': None,
        }),
        ('maintenances', {
            'name': 'maintenances',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Maintenance\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('drivingRecords', {
            'name': 'drivingRecords',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.DrivingRecord\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Maintenance_relational_fields: Set[str] = {
        'vehicle',
        'organization',
        'parts',
    }
_Maintenance_fields: Dict['types.MaintenanceKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('title', {
            'name': 'title',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('maintenanceType', {
            'name': 'maintenanceType',
            'is_list': False,
            'optional': False,
            'type': 'enums.MaintenanceType',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.MaintenanceStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('startDate', {
            'name': 'startDate',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('endDate', {
            'name': 'endDate',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('mileageAtService', {
            'name': 'mileageAtService',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('cost', {
            'name': 'cost',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('provider', {
            'name': 'provider',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('providerContact', {
            'name': 'providerContact',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('documents', {
            'name': 'documents',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('notes', {
            'name': 'notes',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('vehicleId', {
            'name': 'vehicleId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('vehicle', {
            'name': 'vehicle',
            'is_list': False,
            'optional': True,
            'type': 'models.Vehicle',
            'is_relational': True,
            'documentation': None,
        }),
        ('organizationId', {
            'name': 'organizationId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('organization', {
            'name': 'organization',
            'is_list': False,
            'optional': True,
            'type': 'models.Organization',
            'is_relational': True,
            'documentation': None,
        }),
        ('parts', {
            'name': 'parts',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.MaintenancePart\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_MaintenancePart_relational_fields: Set[str] = {
        'maintenance',
    }
_MaintenancePart_fields: Dict['types.MaintenancePartKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('partNumber', {
            'name': 'partNumber',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('quantity', {
            'name': 'quantity',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('unitPrice', {
            'name': 'unitPrice',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('totalPrice', {
            'name': 'totalPrice',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('maintenanceId', {
            'name': 'maintenanceId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('maintenance', {
            'name': 'maintenance',
            'is_list': False,
            'optional': True,
            'type': 'models.Maintenance',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_DriverPerformance_relational_fields: Set[str] = {
        'driver',
    }
_DriverPerformance_fields: Dict['types.DriverPerformanceKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('driverId', {
            'name': 'driverId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('driver', {
            'name': 'driver',
            'is_list': False,
            'optional': True,
            'type': 'models.Driver',
            'is_relational': True,
            'documentation': None,
        }),
        ('periodStart', {
            'name': 'periodStart',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('periodEnd', {
            'name': 'periodEnd',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('totalDistance', {
            'name': 'totalDistance',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('avgSpeed', {
            'name': 'avgSpeed',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('maxSpeed', {
            'name': 'maxSpeed',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('hardBrakeCount', {
            'name': 'hardBrakeCount',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('hardAccelerationCount', {
            'name': 'hardAccelerationCount',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('idlingDuration', {
            'name': 'idlingDuration',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('fuelConsumption', {
            'name': 'fuelConsumption',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('avgFuelEfficiency', {
            'name': 'avgFuelEfficiency',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('co2Emission', {
            'name': 'co2Emission',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('safetyScore', {
            'name': 'safetyScore',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('ecoScore', {
            'name': 'ecoScore',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('overallScore', {
            'name': 'overallScore',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_DrivingRecord_relational_fields: Set[str] = {
        'driver',
        'vehicle',
    }
_DrivingRecord_fields: Dict['types.DrivingRecordKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('driverId', {
            'name': 'driverId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('driver', {
            'name': 'driver',
            'is_list': False,
            'optional': True,
            'type': 'models.Driver',
            'is_relational': True,
            'documentation': None,
        }),
        ('vehicleId', {
            'name': 'vehicleId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('vehicle', {
            'name': 'vehicle',
            'is_list': False,
            'optional': True,
            'type': 'models.Vehicle',
            'is_relational': True,
            'documentation': None,
        }),
        ('startTime', {
            'name': 'startTime',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('endTime', {
            'name': 'endTime',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('startLocation', {
            'name': 'startLocation',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('endLocation', {
            'name': 'endLocation',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('distance', {
            'name': 'distance',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('avgSpeed', {
            'name': 'avgSpeed',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('maxSpeed', {
            'name': 'maxSpeed',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('fuelConsumption', {
            'name': 'fuelConsumption',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('hardBrakeCount', {
            'name': 'hardBrakeCount',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('hardAccelCount', {
            'name': 'hardAccelCount',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('idlingDuration', {
            'name': 'idlingDuration',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('routeData', {
            'name': 'routeData',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('notes', {
            'name': 'notes',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_ERPSyncConfig_relational_fields: Set[str] = {
        'organization',
        'syncLogs',
    }
_ERPSyncConfig_fields: Dict['types.ERPSyncConfigKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('erpSystem', {
            'name': 'erpSystem',
            'is_list': False,
            'optional': False,
            'type': 'enums.ERPSystemType',
            'is_relational': False,
            'documentation': None,
        }),
        ('connectionUrl', {
            'name': 'connectionUrl',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('username', {
            'name': 'username',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('password', {
            'name': 'password',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('syncDirection', {
            'name': 'syncDirection',
            'is_list': False,
            'optional': False,
            'type': 'enums.SyncDirectionType',
            'is_relational': False,
            'documentation': None,
        }),
        ('syncInterval', {
            'name': 'syncInterval',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('syncEnabled', {
            'name': 'syncEnabled',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('lastSyncTime', {
            'name': 'lastSyncTime',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('mappingConfig', {
            'name': 'mappingConfig',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('filters', {
            'name': 'filters',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('organizationId', {
            'name': 'organizationId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('organization', {
            'name': 'organization',
            'is_list': False,
            'optional': True,
            'type': 'models.Organization',
            'is_relational': True,
            'documentation': None,
        }),
        ('syncLogs', {
            'name': 'syncLogs',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ERPSyncLog\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_ERPSyncLog_relational_fields: Set[str] = {
        'config',
        'organization',
    }
_ERPSyncLog_fields: Dict['types.ERPSyncLogKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('configId', {
            'name': 'configId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('config', {
            'name': 'config',
            'is_list': False,
            'optional': True,
            'type': 'models.ERPSyncConfig',
            'is_relational': True,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.SyncStatusType',
            'is_relational': False,
            'documentation': None,
        }),
        ('startTime', {
            'name': 'startTime',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('endTime', {
            'name': 'endTime',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('direction', {
            'name': 'direction',
            'is_list': False,
            'optional': False,
            'type': 'enums.SyncDirectionType',
            'is_relational': False,
            'documentation': None,
        }),
        ('totalItems', {
            'name': 'totalItems',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('processedItems', {
            'name': 'processedItems',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('successItems', {
            'name': 'successItems',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('failedItems', {
            'name': 'failedItems',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('errorDetails', {
            'name': 'errorDetails',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('organizationId', {
            'name': 'organizationId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('organization', {
            'name': 'organization',
            'is_list': False,
            'optional': True,
            'type': 'models.Organization',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Repair_relational_fields: Set[str] = {
        'technician',
        'statusHistories',
    }
_Repair_fields: Dict['types.RepairKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('vehicle_id', {
            'name': 'vehicle_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('repair_type', {
            'name': 'repair_type',
            'is_list': False,
            'optional': False,
            'type': 'enums.RepairType',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('estimated_hours', {
            'name': 'estimated_hours',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('technician_id', {
            'name': 'technician_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('technician', {
            'name': 'technician',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('reservation_id', {
            'name': 'reservation_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('start_time', {
            'name': 'start_time',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('completion_time', {
            'name': 'completion_time',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.RepairStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('parts_required', {
            'name': 'parts_required',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('notes', {
            'name': 'notes',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name': 'updated_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('statusHistories', {
            'name': 'statusHistories',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.StatusHistory\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_StatusHistory_relational_fields: Set[str] = {
        'repair',
        'technician',
    }
_StatusHistory_fields: Dict['types.StatusHistoryKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('repair_id', {
            'name': 'repair_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('repair', {
            'name': 'repair',
            'is_list': False,
            'optional': True,
            'type': 'models.Repair',
            'is_relational': True,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.RepairStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('timestamp', {
            'name': 'timestamp',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('note', {
            'name': 'note',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('technician_id', {
            'name': 'technician_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('technician', {
            'name': 'technician',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)



# we have to import ourselves as relation types are namespaced to models
# e.g. models.Post
from . import models, actions

# required to support relationships between models
model_rebuild(User)
model_rebuild(Permission)
model_rebuild(UserPermission)
model_rebuild(RolePermission)
model_rebuild(Organization)
model_rebuild(OrganizationMember)
model_rebuild(Driver)
model_rebuild(Vehicle)
model_rebuild(Maintenance)
model_rebuild(MaintenancePart)
model_rebuild(DriverPerformance)
model_rebuild(DrivingRecord)
model_rebuild(ERPSyncConfig)
model_rebuild(ERPSyncLog)
model_rebuild(Repair)
model_rebuild(StatusHistory)
